<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    background: black;
    overflow: hidden;
  }
  #player {
    width: 100%;
    height: 100%;
    object-fit: contain;
    background: black;
  }
  #surface {
    position: fixed;
    width: 1px;
    height: 1px;
    left: -9999px;
    top: -9999px;
    opacity: 0;
    pointer-events: none;
  }
</style>
</head>
<body>
  <canvas id="surface"></canvas>
  <video id="player" autoplay playsinline webkit-playsinline></video>
  <script>
    (() => {
      const bridgeName = "floatReceiverBridge";
      const surface = document.getElementById("surface");
      const player = document.getElementById("player");
      const surfaceContext = (() => {
        if (!surface || typeof surface.getContext !== "function") {
          return null;
        }
        try {
          return surface.getContext("2d", { alpha: false, desynchronized: true })
            || surface.getContext("2d", { alpha: false })
            || surface.getContext("2d");
        } catch (_) {
          return surface.getContext("2d", { alpha: false }) || surface.getContext("2d");
        }
      })();
      const receiverState = {
        debugEnabled: false,
      };
      let peerConnection = null;
      let remoteStream = new MediaStream();
      let pendingRemoteCandidates = [];
      let frameLoopActive = false;
      let frameLoopToken = 0;

      player.autoplay = true;
      player.playsInline = true;
      player.controls = false;
      player.srcObject = remoteStream;

      function post(type, payload = {}) {
        const handler = window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers[bridgeName];
        if (!handler) {
          return;
        }
        try {
          handler.postMessage({ type, ...payload });
        } catch (_) {}
      }

      function describeError(error, prefix) {
        const message = error instanceof Error ? error.message : String(error);
        return prefix ? `${prefix}: ${message}` : message;
      }

      function debugLog(event, payload = {}) {
        if (!receiverState.debugEnabled) {
          return;
        }
        post("debug", { event, payload });
      }

      function summarizeTrack(track) {
        if (!track) {
          return null;
        }
        let settings = null;
        try {
          settings = typeof track.getSettings === "function" ? track.getSettings() : null;
        } catch (_) {}
        return {
          kind: track.kind,
          id: track.id,
          enabled: track.enabled,
          muted: track.muted,
          readyState: track.readyState,
          settings,
        };
      }

      function extractOpusFmtpLinesFromSdp(sdp) {
        if (typeof sdp !== "string" || sdp.length === 0) {
          return [];
        }
        const lines = sdp.split("\r\n");
        const opusPayloadTypes = new Set();
        lines.forEach((line) => {
          const match = /^a=rtpmap:(\d+)\s+opus\/48000\/2$/i.exec(line);
          if (match && match[1]) {
            opusPayloadTypes.add(match[1]);
          }
        });

        const fmtpLines = [];
        lines.forEach((line) => {
          const match = /^a=fmtp:(\d+)\s+/i.exec(line);
          if (!match || !match[1] || !opusPayloadTypes.has(match[1])) {
            return;
          }
          fmtpLines.push(line);
        });
        return fmtpLines;
      }

      function appendSdpFmtpParameter(line, key, value) {
        const prefixEnd = line.indexOf(" ");
        if (prefixEnd < 0) {
          return line;
        }
        const prefix = line.slice(0, prefixEnd + 1);
        const rawValue = line.slice(prefixEnd + 1);
        const segments = rawValue
          .split(";")
          .map((segment) => segment.trim())
          .filter((segment) => segment.length > 0);
        const target = `${key}=${value}`;
        const keyPrefix = `${key}=`;
        const existingIndex = segments.findIndex((segment) =>
          segment.toLowerCase().startsWith(keyPrefix.toLowerCase())
        );
        if (existingIndex >= 0) {
          segments[existingIndex] = target;
        } else {
          segments.push(target);
        }
        return `${prefix}${segments.join(";")}`;
      }

      function enforceStereoOpusInSdp(sdp) {
        if (typeof sdp !== "string" || sdp.length === 0) {
          return sdp;
        }
        const lines = sdp.split("\r\n");
        const opusPayloadTypes = new Set();
        lines.forEach((line) => {
          const match = /^a=rtpmap:(\d+)\s+opus\/48000\/2$/i.exec(line);
          if (match && match[1]) {
            opusPayloadTypes.add(match[1]);
          }
        });
        if (opusPayloadTypes.size === 0) {
          return sdp;
        }

        let updated = false;
        const transformed = lines.map((line) => {
          const match = /^a=fmtp:(\d+)\s+/i.exec(line);
          if (!match || !match[1] || !opusPayloadTypes.has(match[1])) {
            return line;
          }
          updated = true;
          let next = appendSdpFmtpParameter(line, "stereo", "1");
          next = appendSdpFmtpParameter(next, "sprop-stereo", "1");
          return next;
        });

        if (!updated) {
          const mutable = [...transformed];
          const opusPayloadType = Array.from(opusPayloadTypes)[0];
          for (let index = 0; index < mutable.length; index += 1) {
            const line = mutable[index];
            if (new RegExp(`^a=rtpmap:${opusPayloadType}\\s+opus/48000/2$`, "i").test(line)) {
              mutable.splice(index + 1, 0, `a=fmtp:${opusPayloadType} stereo=1;sprop-stereo=1`);
              return mutable.join("\r\n");
            }
          }
        }

        return transformed.join("\r\n");
      }

      function updateVideoSize() {
        const width = Number(player.videoWidth || 0);
        const height = Number(player.videoHeight || 0);
        post("videoSize", { width, height });
        debugLog("video.size", {
          width,
          height,
          readyState: player.readyState,
        });
      }

      async function ensurePlayback() {
        try {
          await player.play();
          debugLog("video.play.ok", {
            readyState: player.readyState,
            paused: player.paused,
            muted: player.muted,
            volume: player.volume,
          });
        } catch (error) {
          post("error", { reason: describeError(error, "player.play failed") });
        }
      }

      function streamHasTrack(stream, track) {
        return stream.getTracks().some((existing) => existing.id === track.id);
      }

      function attachTrack(track) {
        if (!track) {
          return;
        }
        if (!remoteStream || streamHasTrack(remoteStream, track)) {
          return;
        }

        remoteStream.addTrack(track);
        player.srcObject = remoteStream;
        updateVideoSize();
        debugLog("track.attach", {
          track: summarizeTrack(track),
          streamTrackCount: remoteStream.getTracks().length,
          audioTrackCount: remoteStream.getAudioTracks().length,
          videoTrackCount: remoteStream.getVideoTracks().length,
        });
        void ensurePlayback();
        post("streaming", { isStreaming: true });

        track.addEventListener("ended", () => {
          debugLog("track.ended", {
            track: summarizeTrack(track),
          });
          if (remoteStream) {
            remoteStream.removeTrack(track);
          }
          if (!remoteStream || remoteStream.getTracks().length === 0) {
            post("streaming", { isStreaming: false });
          }
        });

        track.addEventListener("unmute", () => {
          debugLog("track.unmute", {
            track: summarizeTrack(track),
          });
          if (track.kind === "video") {
            updateVideoSize();
            startFrameLoop();
          }
          void ensurePlayback();
        });
      }

      function drawCurrentFrame() {
        if (!surfaceContext || !surface) {
          return;
        }
        if (player.readyState < 2) {
          return;
        }
        const targetWidth = Math.max(1, surface.width || player.videoWidth || 1);
        const targetHeight = Math.max(1, surface.height || player.videoHeight || 1);
        if (surface.width !== targetWidth) {
          surface.width = targetWidth;
        }
        if (surface.height !== targetHeight) {
          surface.height = targetHeight;
        }
        try {
          surfaceContext.drawImage(player, 0, 0, targetWidth, targetHeight);
        } catch (_) {}
      }

      function runFrameLoop(token) {
        if (!frameLoopActive || token !== frameLoopToken) {
          return;
        }
        drawCurrentFrame();
        if (typeof player.requestVideoFrameCallback === "function") {
          player.requestVideoFrameCallback(() => runFrameLoop(token));
        } else {
          window.requestAnimationFrame(() => runFrameLoop(token));
        }
      }

      function startFrameLoop() {
        if (frameLoopActive) {
          return;
        }
        frameLoopActive = true;
        frameLoopToken += 1;
        debugLog("video.frameLoop.start", { token: frameLoopToken });
        runFrameLoop(frameLoopToken);
      }

      function stopFrameLoop() {
        frameLoopActive = false;
        frameLoopToken += 1;
        debugLog("video.frameLoop.stop", { token: frameLoopToken });
      }

      async function flushPendingRemoteCandidates() {
        if (!peerConnection || !peerConnection.remoteDescription) {
          return;
        }

        while (pendingRemoteCandidates.length > 0) {
          const candidate = pendingRemoteCandidates.shift();
          try {
            await peerConnection.addIceCandidate(candidate);
          } catch (error) {
            post("error", { reason: describeError(error, "addIceCandidate failed") });
          }
        }
      }

      function queueRemoteCandidate(candidate) {
        if (!candidate || typeof candidate.candidate !== "string") {
          return;
        }

        pendingRemoteCandidates.push({
          candidate: candidate.candidate,
          sdpMid: candidate.sdpMid ?? null,
          sdpMLineIndex: candidate.sdpMLineIndex ?? null,
        });

        void flushPendingRemoteCandidates();
      }

      function createPeerConnection() {
        if (typeof RTCPeerConnection !== "function") {
          throw new Error("RTCPeerConnection is unavailable in this WKWebView context");
        }

        const pc = new RTCPeerConnection({ iceServers: [] });
        debugLog("webrtc.pc.create", {
          configuration: { iceServers: [] },
        });

        pc.onicecandidate = (event) => {
          if (!event.candidate) {
            return;
          }
          post("localIce", {
            candidate: event.candidate.candidate,
            sdpMid: event.candidate.sdpMid,
            sdpMLineIndex: event.candidate.sdpMLineIndex,
          });
        };

        pc.ontrack = (event) => {
          debugLog("track.ontrack", {
            track: summarizeTrack(event.track),
            streamCount: event.streams ? event.streams.length : 0,
          });
          attachTrack(event.track);

          if (event.streams && event.streams.length > 0) {
            event.streams.forEach((stream) => {
              stream.getTracks().forEach((track) => attachTrack(track));
            });
          }
        };

        pc.onconnectionstatechange = () => {
          const state = pc.connectionState;
          debugLog("webrtc.connectionState", {
            state,
            iceConnectionState: pc.iceConnectionState,
            iceGatheringState: pc.iceGatheringState,
            signalingState: pc.signalingState,
          });
          post("connectionState", { state });
          if (state === "failed" || state === "closed" || state === "disconnected") {
            post("streaming", { isStreaming: false });
          }
        };

        return pc;
      }

      async function stopInternal() {
        pendingRemoteCandidates = [];
        stopFrameLoop();
        debugLog("receiver.stopInternal", {
          trackCount: remoteStream ? remoteStream.getTracks().length : 0,
          hadPeerConnection: Boolean(peerConnection),
        });

        if (peerConnection) {
          peerConnection.onicecandidate = null;
          peerConnection.ontrack = null;
          peerConnection.onconnectionstatechange = null;
          peerConnection.close();
          peerConnection = null;
        }

        if (remoteStream) {
          remoteStream.getTracks().forEach((track) => {
            remoteStream.removeTrack(track);
          });
        }

        remoteStream = new MediaStream();
        player.pause();
        player.srcObject = null;
        player.srcObject = remoteStream;
        if (surfaceContext && surface) {
          surfaceContext.clearRect(0, 0, surface.width, surface.height);
        }
        post("streaming", { isStreaming: false });
      }

      window.addEventListener("error", (event) => {
        const reason = event && event.message ? String(event.message) : "window error";
        post("error", { reason });
      });

      window.addEventListener("unhandledrejection", (event) => {
        const reason = event && event.reason ? String(event.reason) : "unhandled rejection";
        post("error", { reason });
      });

      player.addEventListener("loadedmetadata", updateVideoSize);
      player.addEventListener("resize", updateVideoSize);
      player.addEventListener("playing", () => {
        debugLog("video.playing", {
          readyState: player.readyState,
          currentTime: player.currentTime,
          paused: player.paused,
          videoWidth: player.videoWidth,
          videoHeight: player.videoHeight,
        });
        startFrameLoop();
        post("streaming", { isStreaming: true });
      });
      player.addEventListener("ended", () => {
        debugLog("video.ended", { currentTime: player.currentTime });
        post("streaming", { isStreaming: false });
      });
      player.addEventListener("error", () => {
        const mediaError = player.error;
        debugLog("video.error", {
          code: mediaError ? mediaError.code : null,
          message: mediaError ? mediaError.message || null : null,
          readyState: player.readyState,
        });
        post("error", { reason: "video element error" });
      });

      window.FloatReceiver = {
        setDebugLoggingEnabled(enabled) {
          receiverState.debugEnabled = Boolean(enabled);
          if (receiverState.debugEnabled) {
            debugLog("receiver.debug.enabled", { enabled: true });
          }
          return receiverState.debugEnabled;
        },

        async handleOffer(offerSdp) {
          if (typeof offerSdp !== "string" || offerSdp.length === 0) {
            throw new Error("Missing offer SDP");
          }

          debugLog("offer.received", {
            sdpLength: offerSdp.length,
            opusFmtpLines: extractOpusFmtpLinesFromSdp(offerSdp),
          });
          await stopInternal();

          peerConnection = createPeerConnection();
          await peerConnection.setRemoteDescription({ type: "offer", sdp: offerSdp });

          const answer = await peerConnection.createAnswer();
          const rawAnswerSdp = (answer && typeof answer.sdp === "string") ? answer.sdp : "";
          const stereoAnswerSdp = enforceStereoOpusInSdp(rawAnswerSdp);
          if (stereoAnswerSdp !== rawAnswerSdp) {
            debugLog("answer.opusStereo.sdpUpdated", {
              before: extractOpusFmtpLinesFromSdp(rawAnswerSdp),
              after: extractOpusFmtpLinesFromSdp(stereoAnswerSdp),
            });
          }
          await peerConnection.setLocalDescription({
            type: "answer",
            sdp: stereoAnswerSdp,
          });
          await flushPendingRemoteCandidates();

          void ensurePlayback();

          const answerSdp = (peerConnection.localDescription && peerConnection.localDescription.sdp) || answer.sdp || "";
          debugLog("answer.created", {
            sdpLength: answerSdp.length,
            opusFmtpLines: extractOpusFmtpLinesFromSdp(answerSdp),
          });

          return answerSdp;
        },

        async addIceCandidate(candidate) {
          queueRemoteCandidate(candidate);
        },

        async stop() {
          await stopInternal();
        }
      };

      post("ready", {
        userAgent: navigator.userAgent,
        isSecureContext: Boolean(window.isSecureContext),
        hasRTCPeerConnection: typeof RTCPeerConnection === "function",
      });
      debugLog("receiver.ready", {
        userAgent: navigator.userAgent,
        isSecureContext: Boolean(window.isSecureContext),
        hasRTCPeerConnection: typeof RTCPeerConnection === "function",
      });
    })();
  </script>
</body>
</html>
